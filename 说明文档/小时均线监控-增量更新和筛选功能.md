# 小时均线监控 - 增量更新和筛选功能说明

## 📋 概述

本次更新为"小时均线监控"功能添加了三个重要特性：
1. **K线增量更新**：从最后一个K线时间到现在，自动获取缺失的K线数据
2. **连续大于/小于EMA计算**：计算价格连续在EMA上方或下方的K线数量
3. **高级筛选功能**：根据连续数量进行灵活筛选

---

## 🎯 新增功能

### 1. K线增量更新

#### 功能说明
- 从本地文件读取最后一个K线的时间
- 自动计算从最后K线到现在缺失的K线数量
- 覆盖最后一个K线（因为可能不完整）
- 去重并保存到本地

#### 使用方法
1. 点击"获取小时K线"按钮初次获取数据
2. 之后点击"🔄 更新K线"按钮进行增量更新
3. 系统会自动：
   - 检查每个合约的最后K线时间
   - 计算距离现在的时间差
   - 如果超过1小时，自动获取缺失的K线
   - 覆盖最后一根K线（防止数据不完整）

#### 技术实现
```csharp
// 服务层：IHourlyEmaService
Task<bool> UpdateHourlyKlinesAsync(Action<HourlyKlineDownloadProgress>? progressCallback = null)

// 核心逻辑
var lastKlineTime = sortedKlines.Last().OpenTime;
var hoursSinceLastKline = (DateTime.UtcNow - lastKlineTime).TotalHours;
var klinesNeeded = (int)Math.Ceiling(hoursSinceLastKline) + 1;

// 移除最后一根K线（可能不完整）
sortedKlines.RemoveAt(sortedKlines.Count - 1);

// 添加新获取的K线并去重
sortedKlines.AddRange(newKlines);
var uniqueKlines = sortedKlines
    .GroupBy(k => k.OpenTime)
    .Select(g => g.First())
    .OrderBy(k => k.OpenTime)
    .ToList();
```

---

### 2. 连续大于/小于EMA计算

#### 功能说明
从最新K线的close价格开始：
- 如果 `close > EMA`：向前计数，累加连续大于EMA的K线数量，直到遇到第一个小于或等于EMA的K线
- 如果 `close < EMA`：向前计数，累加连续小于EMA的K线数量，直到遇到第一个大于或等于EMA的K线
- 如果 `close == EMA`：两个数量都为0

#### 使用方法
1. 获取K线数据后，点击"🔢 计算"按钮
2. 系统会为每个合约计算连续数量
3. 结果会显示在表格的"大于EMA数量"和"小于EMA数量"列中

#### 技术实现
```csharp
// 服务层：IHourlyEmaService
Task<bool> CalculateAboveBelowEmaCountsAsync()

// 核心算法
private (int AboveCount, int BelowCount) CalculateAboveBelowEmaCount(
    List<Kline> sortedKlines, 
    Dictionary<DateTime, decimal> emaValues)
{
    // 从最新K线开始向前遍历
    var latestKline = sortedKlines[index];
    var latestEma = emaValues[latestKline.OpenTime];
    var latestClose = latestKline.ClosePrice;
    
    if (latestClose > latestEma)
    {
        // 计数连续大于EMA的K线
        int aboveCount = 0;
        for (int i = index; i >= 0; i--)
        {
            if (kline.ClosePrice > ema)
                aboveCount++;
            else
                break; // 遇到第一个小于或等于EMA的K线，停止
        }
        return (aboveCount, 0);
    }
    else if (latestClose < latestEma)
    {
        // 计数连续小于EMA的K线
        // ... 类似逻辑
        return (0, belowCount);
    }
    
    return (0, 0);
}
```

---

### 3. 高级筛选功能

#### 功能说明
支持两种筛选条件：
- **大于EMA数量 ≥ X**：筛选连续大于EMA数量大于等于X的合约
- **小于EMA数量 ≥ Y**：筛选连续小于EMA数量大于等于Y的合约
- 可以单独使用任一条件，也可以组合使用

#### 使用方法
1. 在筛选条件输入框中输入数值
   - 大于EMA数量：例如输入 `5`，表示只显示连续大于EMA至少5根K线的合约
   - 小于EMA数量：例如输入 `3`，表示只显示连续小于EMA至少3根K线的合约
2. 点击"🔍 筛选"按钮应用筛选
3. 点击"清除筛选"按钮恢复显示所有合约

#### 技术实现
```csharp
// 数据模型
public class HourlyEmaFilter
{
    public int? MinAboveEmaCount { get; set; }
    public int? MinBelowEmaCount { get; set; }
}

// 服务层方法
Task<List<HourlyEmaMonitorResult>> GetMonitorResultsAsync(HourlyEmaFilter? filter = null)

// 筛选逻辑
if (filter != null)
{
    if (filter.MinAboveEmaCount.HasValue && result.AboveEmaCount < filter.MinAboveEmaCount.Value)
        continue; // 不符合条件，跳过
        
    if (filter.MinBelowEmaCount.HasValue && result.BelowEmaCount < filter.MinBelowEmaCount.Value)
        continue; // 不符合条件，跳过
}
```

---

## 📊 数据模型更新

### HourlyEmaMonitorResult
新增两个字段：

```csharp
public class HourlyEmaMonitorResult
{
    // ... 原有字段 ...
    
    /// <summary>
    /// 连续大于EMA的K线数量
    /// </summary>
    public int AboveEmaCount { get; set; }

    /// <summary>
    /// 连续小于EMA的K线数量
    /// </summary>
    public int BelowEmaCount { get; set; }
}
```

### HourlyEmaFilter
新增筛选条件模型：

```csharp
public class HourlyEmaFilter
{
    /// <summary>
    /// 最小大于EMA数量
    /// </summary>
    public int? MinAboveEmaCount { get; set; }

    /// <summary>
    /// 最小小于EMA数量
    /// </summary>
    public int? MinBelowEmaCount { get; set; }
}
```

---

## 🖥️ UI 更新

### 新增按钮
1. **🔄 更新K线**：执行增量更新
2. **🔢 计算**：计算连续大于/小于EMA数量

### 新增筛选区域
- 两个输入框：大于EMA数量、小于EMA数量
- 两个按钮：筛选、清除筛选

### 表格新增列
- **大于EMA数量**：显示连续大于EMA的K线数量
- **小于EMA数量**：显示连续小于EMA的K线数量
- 两列都支持点击列标题排序

---

## 🔄 工作流程

### 完整使用流程
```
1. 点击"📥 获取小时K线" 
   ↓
2. 系统自动计算EMA
   ↓
3. 启用"🔄 更新K线"和"🔢 计算"按钮
   ↓
4. (可选) 点击"🔄 更新K线" - 增量更新到最新数据
   ↓
5. 点击"🔢 计算" - 计算连续数量
   ↓
6. (可选) 输入筛选条件并点击"🔍 筛选"
   ↓
7. 查看筛选后的结果（支持列排序）
   ↓
8. (可选) 点击"清除筛选" - 恢复显示全部
   ↓
9. (可选) 点击"▶️ 启动监控" - 自动定时刷新
```

### 增量更新时机
建议在以下情况下执行增量更新：
- 首次获取K线后经过一段时间（1小时以上）
- 想要确保数据是最新的
- 监控中发现数据滞后

---

## 📝 服务接口更新

### IHourlyEmaService
新增三个方法：

```csharp
/// <summary>
/// 增量更新K线数据（从最后一个K线到现在）
/// </summary>
Task<bool> UpdateHourlyKlinesAsync(Action<HourlyKlineDownloadProgress>? progressCallback = null);

/// <summary>
/// 计算连续大于/小于EMA的K线数量
/// </summary>
Task<bool> CalculateAboveBelowEmaCountsAsync();

/// <summary>
/// 获取所有合约的监控结果
/// </summary>
/// <param name="filter">筛选条件（可选）</param>
Task<List<HourlyEmaMonitorResult>> GetMonitorResultsAsync(HourlyEmaFilter? filter = null);
```

---

## 🎨 UI 按钮状态管理

### 按钮启用/禁用逻辑

| 状态 | 获取K线 | 更新K线 | 计算 | 启动监控 | 停止监控 |
|------|---------|---------|------|----------|----------|
| 初始状态 | ✅ | ❌ | ❌ | ❌ | ❌ |
| 获取成功 | ✅ | ✅ | ✅ | ✅ | ❌ |
| 监控中 | ❌ | ❌ | ❌ | ❌ | ✅ |
| 停止监控 | ✅ | ✅ | ✅ | ✅ | ❌ |
| 缓存清除 | ✅ | ❌ | ❌ | ❌ | ❌ |

---

## 💡 使用场景示例

### 场景1：找出持续上涨的合约
```
1. 获取K线数据
2. 点击"计算"
3. 在"大于EMA数量"筛选框输入：5
4. 点击"筛选"
→ 显示连续5根以上K线都在EMA上方的合约（强势上涨）
```

### 场景2：找出持续下跌的合约
```
1. 获取K线数据
2. 点击"计算"
3. 在"小于EMA数量"筛选框输入：3
4. 点击"筛选"
→ 显示连续3根以上K线都在EMA下方的合约（弱势下跌）
```

### 场景3：日常监控更新
```
1. 首次获取K线数据
2. 启动监控（自动5分钟刷新一次）
3. 经过几小时后，停止监控
4. 点击"更新K线"（增量更新）
5. 点击"计算"（重新计算连续数量）
6. 应用筛选条件查看最新结果
```

---

## ⚠️ 注意事项

1. **增量更新时机**：
   - 只有在获取过K线数据后，"更新K线"按钮才会启用
   - 增量更新会覆盖最后一根K线，确保数据完整性

2. **计算按钮**：
   - 必须先获取K线数据并计算EMA后才能使用
   - 每次更新K线后，建议重新点击"计算"更新连续数量

3. **筛选功能**：
   - 筛选条件至少需要输入一个
   - 输入必须是大于0的整数
   - 可以同时使用两个条件（AND关系）

4. **监控状态**：
   - 监控期间会禁用"获取K线"、"更新K线"和"计算"按钮
   - 停止监控后会自动恢复按钮状态

5. **数据存储**：
   - 连续大于/小于EMA的计数暂时存储在内存中
   - 清除缓存后需要重新获取和计算

---

## 📁 修改文件列表

### 后端服务层
- `src/BinanceApps.Core/Models/HourlyEmaModels.cs` - 更新
- `src/BinanceApps.Core/Interfaces/IHourlyEmaService.cs` - 更新
- `src/BinanceApps.Core/Services/HourlyEmaService.cs` - 更新

### WPF前端
- `src/BinanceApps.WPF/HourlyEmaMonitorWindow.xaml` - 更新
- `src/BinanceApps.WPF/HourlyEmaMonitorWindow.xaml.cs` - 更新

---

## ✅ 测试建议

### 测试1：增量更新
1. 获取K线数据
2. 等待1小时以上
3. 点击"更新K线"
4. 验证日志输出显示正确的更新信息

### 测试2：计算功能
1. 获取K线数据
2. 点击"计算"
3. 检查表格中"大于EMA数量"和"小于EMA数量"列是否有值
4. 双击列标题测试排序功能

### 测试3：筛选功能
1. 输入筛选条件（如：大于EMA数量 ≥ 3）
2. 点击"筛选"
3. 验证结果只显示符合条件的合约
4. 点击"清除筛选"验证恢复显示全部

### 测试4：按钮状态
1. 验证初始状态下"更新K线"和"计算"按钮禁用
2. 获取K线后验证按钮启用
3. 启动监控后验证这些按钮再次禁用
4. 停止监控后验证按钮恢复启用

---

## 🔧 技术要点

### 增量更新算法
```csharp
// 1. 找到最后一个K线时间
var lastKlineTime = sortedKlines.Last().OpenTime;

// 2. 计算时间差（小时）
var hoursSinceLastKline = (DateTime.UtcNow - lastKlineTime).TotalHours;

// 3. 计算需要获取的K线数量（+1是为了覆盖最后一根）
var klinesNeeded = (int)Math.Ceiling(hoursSinceLastKline) + 1;

// 4. 移除最后一根（可能不完整）
sortedKlines.RemoveAt(sortedKlines.Count - 1);

// 5. 添加新K线并去重
sortedKlines.AddRange(newKlines);
var uniqueKlines = sortedKlines
    .GroupBy(k => k.OpenTime)
    .Select(g => g.First())
    .OrderBy(k => k.OpenTime)
    .ToList();
```

### 连续计数算法
```csharp
// 从最新K线开始向前遍历
for (int i = index; i >= 0; i--)
{
    var kline = sortedKlines[i];
    var ema = emaValues[kline.OpenTime];
    
    if (kline.ClosePrice > ema)  // 或 < 根据方向
    {
        count++;
    }
    else
    {
        break;  // 遇到第一个反向K线，停止计数
    }
}
```

---

## 📅 版本信息

- **更新日期**：2025-11-06
- **功能版本**：v2.0
- **主要改进**：
  1. 增量K线更新
  2. 连续大于/小于EMA计算
  3. 高级筛选功能
  4. UI优化和按钮状态管理

---

## 📞 问题反馈

如有任何问题或建议，请查看控制台输出日志，或联系开发团队。

---

**文档结束** 🎉

